<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riva Real-time ASR Demo</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected { background-color: #28a745; }
        .status-disconnected { background-color: #dc3545; }
        .status-transcribing { background-color: #ffc107; }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0056b3;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-success {
            background-color: #28a745;
            color: white;
        }

        .btn-success:hover {
            background-color: #1e7e34;
        }

        .btn-danger {
            background-color: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .btn-warning {
            background-color: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background-color: #e0a800;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .config-panel {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .config-row {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .config-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="text"], input[type="number"], select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 14px;
        }

        input[type="checkbox"] {
            margin: 0;
        }

        label {
            font-weight: 500;
            color: #555;
        }

        .transcription-panel {
            min-height: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background-color: #fafafa;
            margin-bottom: 20px;
        }

        .transcription-result {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }

        .transcription-final {
            background-color: #d4edda;
            border-left-color: #28a745;
        }

        .transcription-partial {
            background-color: #fff3cd;
            border-left-color: #ffc107;
            font-style: italic;
        }

        .transcription-error {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }

        .timestamp {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .confidence {
            font-size: 12px;
            color: #666;
            float: right;
        }

        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .metric-card {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .metric-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 10px;
        }

        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #007bff;
        }

        .metric-label {
            font-size: 12px;
            color: #6c757d;
        }

        .audio-visualizer {
            width: 100%;
            height: 60px;
            background-color: #000;
            border-radius: 3px;
            margin: 10px 0;
        }

        .log-panel {
            max-height: 200px;
            overflow-y: auto;
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
        }

        .log-timestamp {
            color: #90cdf4;
        }

        .log-level {
            font-weight: bold;
        }

        .log-info { color: #68d391; }
        .log-warn { color: #fbb74e; }
        .log-error { color: #f56565; }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .config-row {
                flex-direction: column;
                align-items: stretch;
            }

            .metrics-panel {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¤ Riva Real-time ASR Demo</h1>
        <div style="text-align: center; color: #666; font-size: 12px; margin-top: -15px; margin-bottom: 20px;">
            Version 2.6.0 | Option A + Deduplication Filter (removes RIVA repetitions)
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div>
                <span id="connectionStatus" class="status-indicator status-disconnected"></span>
                <span id="connectionText">Disconnected</span>
            </div>
            <div>
                <span id="transcriptionStatus" class="status-indicator status-disconnected"></span>
                <span id="transcriptionText">Not Transcribing</span>
            </div>
            <div id="connectionId">Connection ID: None</div>
        </div>

        <!-- Configuration Panel -->
        <div class="config-panel">
            <h3>Configuration</h3>
            <div class="config-row">
                <div class="config-item">
                    <label for="serverUrl">Server URL:</label>
                    <input type="text" id="serverUrl" value="wss://3.16.124.227:8443/">
                </div>
                <div class="config-item">
                    <label for="enablePartials">
                        <input type="checkbox" id="enablePartials" checked> Enable Partials
                    </label>
                </div>
                <div class="config-item">
                    <label for="frameMs">Frame Size (ms):</label>
                    <select id="frameMs">
                        <option value="50">50ms</option>
                        <option value="100" selected>100ms</option>
                        <option value="200">200ms</option>
                    </select>
                </div>
            </div>
            <div class="config-row">
                <div class="config-item">
                    <label for="hotwords">Hotwords (comma-separated):</label>
                    <input type="text" id="hotwords" placeholder="e.g., hello, world, test">
                </div>
                <div class="config-item">
                    <label for="autoStart">
                        <input type="checkbox" id="autoStart"> Auto-start transcription
                    </label>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button id="connectBtn" class="btn-primary">Connect</button>
            <button id="disconnectBtn" class="btn-secondary" disabled>Disconnect</button>
            <button id="startTranscriptionBtn" class="btn-success" disabled>Start Transcription</button>
            <button id="stopTranscriptionBtn" class="btn-danger" disabled>Stop Transcription</button>
            <button id="clearTranscriptsBtn" class="btn-warning">Clear</button>
            <button id="metricsBtn" class="btn-secondary" disabled>Get Metrics</button>
            <button id="pingBtn" class="btn-secondary" disabled>Ping</button>
        </div>

        <!-- Audio Visualizer -->
        <canvas id="audioVisualizer" class="audio-visualizer"></canvas>

        <!-- Transcription Results -->
        <div class="transcription-panel" id="transcriptionPanel">
            <h3>Transcription Results</h3>
            <div id="transcriptionResults">
                <p style="color: #666; text-align: center;">Click "Connect" and "Start Transcription" to begin...</p>
            </div>
        </div>

        <!-- Metrics Panel -->
        <div class="metrics-panel" id="metricsPanel">
            <!-- Metrics will be populated dynamically -->
        </div>

        <!-- Debug Log -->
        <div class="log-panel" id="logPanel">
            <!-- Logs will be populated dynamically -->
        </div>
    </div>

    <script src="riva-websocket-client.js"></script>
    <script>
        class RivaDemoApp {
            constructor() {
                this.client = null;
                this.isConnected = false;
                this.isTranscribing = false;
                this.transcriptionCount = 0;
                this.audioVisualizer = null;

                // Hybrid accumulator for transcription display
                this.finalTranscript = '';  // Accumulated final results
                this.currentPartial = '';   // Latest partial (temporary)

                this.initializeUI();
                this.setupAudioVisualizer();
                this.log('Demo application initialized');
            }

            initializeUI() {
                // Get UI elements
                this.elements = {
                    connectBtn: document.getElementById('connectBtn'),
                    disconnectBtn: document.getElementById('disconnectBtn'),
                    startTranscriptionBtn: document.getElementById('startTranscriptionBtn'),
                    stopTranscriptionBtn: document.getElementById('stopTranscriptionBtn'),
                    clearTranscriptsBtn: document.getElementById('clearTranscriptsBtn'),
                    metricsBtn: document.getElementById('metricsBtn'),
                    pingBtn: document.getElementById('pingBtn'),

                    serverUrl: document.getElementById('serverUrl'),
                    enablePartials: document.getElementById('enablePartials'),
                    frameMs: document.getElementById('frameMs'),
                    hotwords: document.getElementById('hotwords'),
                    autoStart: document.getElementById('autoStart'),

                    connectionStatus: document.getElementById('connectionStatus'),
                    connectionText: document.getElementById('connectionText'),
                    transcriptionStatus: document.getElementById('transcriptionStatus'),
                    transcriptionText: document.getElementById('transcriptionText'),
                    connectionId: document.getElementById('connectionId'),

                    transcriptionResults: document.getElementById('transcriptionResults'),
                    metricsPanel: document.getElementById('metricsPanel'),
                    logPanel: document.getElementById('logPanel')
                };

                // Add event listeners
                this.elements.connectBtn.addEventListener('click', () => this.connect());
                this.elements.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.elements.startTranscriptionBtn.addEventListener('click', () => this.startTranscription());
                this.elements.stopTranscriptionBtn.addEventListener('click', () => this.stopTranscription());
                this.elements.clearTranscriptsBtn.addEventListener('click', () => this.clearTranscripts());
                this.elements.metricsBtn.addEventListener('click', () => this.getMetrics());
                this.elements.pingBtn.addEventListener('click', () => this.ping());

                // Auto-detect server URL
                this.elements.serverUrl.value = this.detectServerUrl();
            }

            detectServerUrl() {
                // WebSocket bridge always uses WSS (TLS) on port 8443
                const protocol = 'wss:';
                const host = window.location.hostname;
                const port = '8443';
                return `${protocol}//${host}:${port}/`;
            }

            setupAudioVisualizer() {
                const canvas = document.getElementById('audioVisualizer');
                this.audioVisualizer = {
                    canvas: canvas,
                    ctx: canvas.getContext('2d'),
                    width: canvas.width = canvas.offsetWidth,
                    height: canvas.height = 60,
                    data: new Array(128).fill(0)
                };

                // Start animation loop
                this.animateVisualizer();
            }

            animateVisualizer() {
                const { ctx, width, height, data } = this.audioVisualizer;

                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);

                // Draw waveform
                ctx.strokeStyle = this.isTranscribing ? '#00ff00' : '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < data.length; i++) {
                    const x = (i / data.length) * width;
                    const y = height / 2 + (data[i] * height / 4);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.stroke();

                // Animate data (simulate audio activity)
                if (this.isTranscribing) {
                    for (let i = 0; i < data.length; i++) {
                        data[i] = Math.sin(Date.now() * 0.01 + i * 0.1) * Math.random() * 0.5;
                    }
                } else {
                    for (let i = 0; i < data.length; i++) {
                        data[i] *= 0.95; // Fade out
                    }
                }

                requestAnimationFrame(() => this.animateVisualizer());
            }

            async connect() {
                try {
                    this.log('Connecting to server...');

                    // Get configuration
                    const config = {
                        serverUrl: this.elements.serverUrl.value,
                        enablePartials: this.elements.enablePartials.checked,
                        frameMs: parseInt(this.elements.frameMs.value),
                        hotwords: this.elements.hotwords.value.split(',').map(w => w.trim()).filter(w => w)
                    };

                    // Create client
                    this.client = new RivaWebSocketClient(config);

                    // Add event listeners
                    this.client.on('connection', (data) => this.handleConnection(data));
                    this.client.on('display', (data) => this.handleDisplay(data));  // Server-side accumulator
                    this.client.on('transcription', (data) => this.handleTranscription(data));
                    this.client.on('partial', (data) => this.handlePartial(data));
                    this.client.on('error', (data) => this.handleError(data));
                    this.client.on('session_started', (data) => this.handleSessionStarted(data));
                    this.client.on('session_stopped', (data) => this.handleSessionStopped(data));
                    this.client.on('metrics', (data) => this.handleMetrics(data));
                    this.client.on('disconnect', (data) => this.handleDisconnect(data));

                    // Connect
                    await this.client.connect();

                } catch (error) {
                    this.log(`Connection failed: ${error.message}`, 'error');
                    alert('Failed to connect: ' + error.message);
                }
            }

            async disconnect() {
                if (this.client) {
                    await this.client.disconnect();
                    this.client = null;
                }
            }

            async startTranscription() {
                if (this.client) {
                    try {
                        await this.client.startTranscription();
                    } catch (error) {
                        this.log(`Failed to start transcription: ${error.message}`, 'error');
                        alert('Failed to start transcription: ' + error.message);
                    }
                }
            }

            async stopTranscription() {
                if (this.client) {
                    await this.client.stopTranscription();
                }
            }

            getMetrics() {
                if (this.client) {
                    this.client.requestMetrics();

                    // Also show client metrics
                    const clientMetrics = this.client.getClientMetrics();
                    this.updateMetricsDisplay({ client: clientMetrics });
                }
            }

            ping() {
                if (this.client) {
                    this.client.ping();
                    this.log('Ping sent');
                }
            }

            clearTranscripts() {
                this.finalTranscript = '';
                this.currentPartial = '';
                this.elements.transcriptionResults.innerHTML =
                    '<p style="color: #666; text-align: center;">Transcripts cleared</p>';
                this.transcriptionCount = 0;
            }

            updateTranscriptionDisplay() {
                const resultsEl = this.elements.transcriptionResults;

                // Build display text with styling
                let html = '';

                if (!this.finalTranscript && !this.currentPartial) {
                    html = '<p style="color: #666; text-align: center;">No transcriptions yet...</p>';
                } else {
                    html = '<div style="padding: 15px; line-height: 1.8; font-size: 16px;">';

                    // Final transcript (stable, permanent, black text)
                    if (this.finalTranscript) {
                        html += `<span style="color: #000; font-weight: 500;">${this.escapeHtml(this.finalTranscript)}</span>`;
                    }

                    // Current partial (tentative, gray italic)
                    if (this.currentPartial) {
                        html += `<span style="color: #888; font-style: italic; background-color: #f0f0f0; padding: 2px 6px; border-radius: 3px;">${this.escapeHtml(this.currentPartial)}</span>`;
                    }

                    html += '</div>';

                    // Add metadata footer
                    html += '<div style="padding: 10px 15px; font-size: 12px; color: #666; border-top: 1px solid #eee;">';
                    html += `<strong>Words:</strong> ${this.finalTranscript.split(' ').filter(w => w.trim()).length} final`;
                    if (this.currentPartial) {
                        html += ` + ${this.currentPartial.split(' ').filter(w => w.trim()).length} partial`;
                    }
                    html += ` | <strong>Utterances:</strong> ${this.transcriptionCount}`;
                    html += '</div>';
                }

                resultsEl.innerHTML = html;
                resultsEl.scrollTop = resultsEl.scrollHeight;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Event handlers
            handleConnection(data) {
                this.isConnected = true;
                this.updateConnectionStatus();
                this.elements.connectionId.textContent = `Connection ID: ${data.connection_id}`;
                this.log(`Connected: ${data.connection_id}`);

                // Auto-start transcription if enabled
                if (this.elements.autoStart.checked) {
                    setTimeout(() => this.startTranscription(), 1000);
                }
            }

            handleTranscription(data) {
                // Add to final transcript buffer (permanent)
                if (data.text && data.text.trim()) {
                    this.finalTranscript += data.text + ' ';
                }
                this.currentPartial = '';  // Clear partial after final arrives
                this.updateTranscriptionDisplay();
                this.log(`Final: "${data.text}" (confidence: ${data.confidence || 'N/A'})`);
                this.transcriptionCount++;
            }

            handlePartial(data) {
                // Legacy handler for backward compatibility (not used with server-side accumulator)
                this.currentPartial = data.text || '';
                this.updateTranscriptionDisplay();
                this.log(`Partial: "${data.text}"`);
            }

            handleDisplay(data) {
                // Handle server-side accumulator display events
                // data contains: stable_text, partial_suffix, is_final, segment_id, metadata
                this.finalTranscript = data.stable_text || '';
                this.currentPartial = data.partial_suffix || '';
                this.updateTranscriptionDisplay();

                // Count final events for utterance tracking
                if (data.is_final) {
                    this.transcriptionCount++;
                }

                // Log with metadata
                const metadata = data.metadata || {};
                this.log(
                    `Display: ${metadata.stable_word_count || 0} stable words, ` +
                    `${metadata.pending_tokens || 0} pending | segment=${data.segment_id || 0}` +
                    (data.is_final ? ' [FINAL]' : '')
                );
            }

            handleError(data) {
                // Show error in log
                this.log(`Error: ${data.error}`, 'error');

                // Optionally append error to display
                const errorMsg = `[ERROR: ${data.error}]`;
                this.finalTranscript += errorMsg + ' ';
                this.updateTranscriptionDisplay();
            }

            handleSessionStarted(data) {
                this.isTranscribing = true;
                this.updateTranscriptionStatus();
                this.log('Transcription session started');
            }

            handleSessionStopped(data) {
                this.isTranscribing = false;
                this.updateTranscriptionStatus();
                this.log('Transcription session stopped');
            }

            handleMetrics(data) {
                this.updateMetricsDisplay(data);
                this.log('Metrics updated');
            }

            handleDisconnect(data) {
                this.isConnected = false;
                this.isTranscribing = false;
                this.updateConnectionStatus();
                this.updateTranscriptionStatus();
                this.elements.connectionId.textContent = 'Connection ID: None';
                this.log(`Disconnected: ${data.reason || 'Unknown reason'}`);
            }

            // UI update methods
            updateConnectionStatus() {
                const statusEl = this.elements.connectionStatus;
                const textEl = this.elements.connectionText;

                if (this.isConnected) {
                    statusEl.className = 'status-indicator status-connected';
                    textEl.textContent = 'Connected';
                } else {
                    statusEl.className = 'status-indicator status-disconnected';
                    textEl.textContent = 'Disconnected';
                }

                // Update button states
                this.elements.connectBtn.disabled = this.isConnected;
                this.elements.disconnectBtn.disabled = !this.isConnected;
                this.elements.startTranscriptionBtn.disabled = !this.isConnected || this.isTranscribing;
                this.elements.stopTranscriptionBtn.disabled = !this.isConnected || !this.isTranscribing;
                this.elements.metricsBtn.disabled = !this.isConnected;
                this.elements.pingBtn.disabled = !this.isConnected;
            }

            updateTranscriptionStatus() {
                const statusEl = this.elements.transcriptionStatus;
                const textEl = this.elements.transcriptionText;

                if (this.isTranscribing) {
                    statusEl.className = 'status-indicator status-transcribing';
                    textEl.textContent = 'Transcribing';
                } else {
                    statusEl.className = 'status-indicator status-disconnected';
                    textEl.textContent = 'Not Transcribing';
                }

                // Update button states
                this.elements.startTranscriptionBtn.disabled = !this.isConnected || this.isTranscribing;
                this.elements.stopTranscriptionBtn.disabled = !this.isConnected || !this.isTranscribing;
            }

            updateMetricsDisplay(data) {
                const metricsPanel = this.elements.metricsPanel;
                metricsPanel.innerHTML = '';

                // Create metric cards
                const sections = Object.keys(data);
                sections.forEach(section => {
                    const sectionData = data[section];
                    if (typeof sectionData === 'object') {
                        const card = this.createMetricCard(section.charAt(0).toUpperCase() + section.slice(1), sectionData);
                        metricsPanel.appendChild(card);
                    }
                });
            }

            createMetricCard(title, data) {
                const card = document.createElement('div');
                card.className = 'metric-card';

                let html = `<div class="metric-title">${title}</div>`;

                Object.entries(data).forEach(([key, value]) => {
                    if (typeof value === 'number') {
                        const formattedValue = Number.isInteger(value) ? value.toString() : value.toFixed(2);
                        html += `
                            <div style="margin-bottom: 8px;">
                                <div class="metric-value">${formattedValue}</div>
                                <div class="metric-label">${key.replace(/([A-Z])/g, ' $1').toLowerCase()}</div>
                            </div>
                        `;
                    } else if (typeof value === 'boolean') {
                        html += `
                            <div style="margin-bottom: 8px;">
                                <div class="metric-value">${value ? 'Yes' : 'No'}</div>
                                <div class="metric-label">${key.replace(/([A-Z])/g, ' $1').toLowerCase()}</div>
                            </div>
                        `;
                    } else if (typeof value === 'string') {
                        html += `
                            <div style="margin-bottom: 8px;">
                                <div class="metric-value" style="font-size: 14px;">${value}</div>
                                <div class="metric-label">${key.replace(/([A-Z])/g, ' $1').toLowerCase()}</div>
                            </div>
                        `;
                    }
                });

                card.innerHTML = html;
                return card;
            }

            log(message, level = 'info') {
                const logPanel = this.elements.logPanel;
                const timestamp = new Date().toLocaleTimeString();

                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span>
                    <span class="log-level log-${level}">[${level.toUpperCase()}]</span>
                    ${message}
                `;

                logPanel.appendChild(logEntry);
                logPanel.scrollTop = logPanel.scrollHeight;

                // Keep only last 100 log entries
                while (logPanel.children.length > 100) {
                    logPanel.removeChild(logPanel.firstChild);
                }

                console.log(`[${timestamp}] [${level.toUpperCase()}] ${message}`);
            }
        }

        // Initialize application when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new RivaDemoApp();
        });
    </script>
</body>
</html>